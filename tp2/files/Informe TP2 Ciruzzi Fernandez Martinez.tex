\documentclass[a4paper,10pt]{article}

\usepackage{graphicx}
\usepackage[ansinew]{inputenc}
\usepackage[spanish]{babel}
\usepackage{listings} 
\usepackage{tabto}
\usepackage{float}
\usepackage[justification=centering]{caption}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{mips}
\usepackage[section]{placeins}
\usepackage{pdfpages}
\usepackage{enumitem}
\usepackage{microtype}
\DisableLigatures[-]{}


\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\circ$}


\title{		\textbf{Trabajo práctico \#2: datapath}}

\author{	Santiago Fernandez, \textit{Padrón Nro. 94.489}                     \\
            \texttt{ fernandezsantid@gmail.com }                                              \\[2.5ex]
            Pablo Rodrigo Ciruzzi, \textit{Padrón Nro. 95.748}                     \\
            \texttt{ p.ciruzzi@hotmail.com }                                              \\[2.5ex]
            Horacio Martinez, \textit{Padrón Nro. 94.926 }                     \\
            \texttt{ hmk142@hotmail.com }                                              \\[2.5ex]
            \normalsize{2do. Cuatrimestre de 2015}                                      \\
            \normalsize{66.20 Organización de Computadoras  $-$ Práctica Jueves}  \\
            \normalsize{Facultad de Ingeniería, Universidad de Buenos Aires}            \\
            \\
            \\
       }
\date{ 26 de Noviembre, 2015}

\begin{document}
\sloppy

\maketitle
\thispagestyle{empty}   % quita el número en la primer página


\begin{abstract}
En este trabajo práctico se verán modificaciones a distintos datapaths de una arquitectura MIPS, con el fin de agregar algunas instrucciones que no han sido implementadas en el mismo, y así poder familiarizarse con dicho concepto. La herramienta utilizada fue el DrMIPS version 2.0 [1][2].
\end{abstract}
\pagebreak 

\tableofcontents
\pagebreak

\section{Introducción}
\par DrMIPS [1][2] nos permite modificar el datapath de una arquitectura MIPS32 y su conjunto de instrucciones. Usaremos esta herramienta para agregar las siguientes instrucciones: tres de ellas (\emph{sll}, \emph{srl} y \emph{jr}) al datapath monociclo y las otras dos (\emph{j} y \emph{blt}) al datapath pipeline.
\par Para lograrlo, agregaremos nuevos componentes al datapath y/o modificaremos el set de instrucciones, según sea necesario.

\section{Desarrollo}
\par Para el desarrollo del TP se utilizaron 2 \emph{datapaths} distintos como base: uno monociclo y otro multiciclo, los cuales se muestran en las figuras \ref{fig:DPmonocicloOrig} y \ref{fig:DPpipelineOrig} respectivamente. Cada uno de ellos se usó con su respectivo set de instrucciones. Ambas cosas eran simplemente modificables mediante un archivo JSON.

\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.4]{img/DPmonocicloOriginal.pdf}
	\caption{Datapath monociclo.}
	\label{fig:DPmonocicloOrig}
\end{figure}

\pagebreak

\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.37]{img/DPpipelineOriginal.pdf}
	\caption{Datapath pipeline.}
	\label{fig:DPpipelineOrig}
\end{figure}

\subsection{Punto 1}
\par En este ítem, se agregaron las instrucciones \emph{sll} y \emph{srl} al datapath monociclo. Para ello, no fue necesario modificar el datapath, simplemente bastó con agregar las instrucciones al set de instrucciones.

\subsubsection{Modificación al set de instrucciones}
Se agregaron las siguientes líneas al campo \emph{instructions} del archivo \emph{default.set}:
\begin{verbatim}
"sll": {
        "type": "R", "args": ["reg", "reg", "reg"],
        "fields": {"op": 0, "rs": "#2", "rt": "#3", 
                   "rd": "#1", "shamt": "#3", "func": 0}, 
        "desc": "$t1 = $t2 << $t3 = $t2 * 2^$t3"
},
"srl": {
        "type": "R", "args": ["reg", "reg", "reg"], 
        "fields": {"op": 0, "rs": "#2", "rt": "#3", 
                   "rd": "#1", "shamt": "#3", "func": 2}, 
        "desc": "$t1 = $t2 >> $t3 = $t2 / 2^$t3"
},
\end{verbatim}
\par Lo que esto hace, es definir dos instrucciones nuevas del tipo R, que reciben como argumento tres registros. Lo más importante a destacar es el uso del campo \emph{shamt}, que generalmente no se utiliza en otras instrucciones. Luego, el campo \emph{func}, junto con el \emph{aluop}, será el que referencie a estas instrucciones en la sección de control de la ALU, por lo tanto, al ejecutarlas, la entrada de la ALU será la especificada. Por último, debemos asociar esta entrada con la operación a realizarse, esto lo hacemos en la configuración de la ALU de la siguiente manera:
\begin{verbatim}
"alu": {
    ...
    "control": [
        ...
        {"aluop": 2, "func": 0, "out": {"Operation": 8}},
        {"aluop": 2, "func": 2, "out": {"Operation": 9}},
        ...
    ],
    "operations": {
        ...
        "8": "sll",
        "9": "srl",
        ...
    }
}
\end{verbatim}
\par Esto le indica a la sección de control de la ALU, que ante el \emph{aluop}=2 y \emph{func}=0, debe ejecutar la operación 8, en este caso definida como \emph{sll}, lo cual ocurre análogamente con \emph{srl}.

\subsubsection{Pruebas de sll y srl}
\par Estas fueron las pruebas que se corrieron para verificar el correcto funcionamiento de las nuevas instrucciones:

\bigskip
\noindent \textbf{Prueba 1:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto1/prueba.asm}
\medskip
\textbf{Prueba 2:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto1/prueba2.asm}
\medskip
\textbf{Prueba 3:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto1/prueba3.asm}
\medskip
\textbf{Prueba 4:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto1/prueba4.asm}
\medskip
\textbf{Prueba 5:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto1/prueba5.asm}

\pagebreak

\subsection{Punto 2}
\par En este punto se pedía implementar la instrucción \emph{j} (jump) en el datapath del pipeline. La principal diferencia de esta instrucción con el \emph{branch} es que en este caso el salto es relativo a la posición actual, mientras que el de la instrucción \emph{jump} es absoluto.
\par Para llevar a cabo dicha instrucción, lo que se quiso implementar fue algo similar a lo que ocurre entre el datapath monociclo original y el datapath monociclo sin jump (ver figura \ref{fig:DPmonocicloNoJump} ).

\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.31]{img/DPmonocicloNoJump.pdf}
	\caption{Datapath monociclo sin instrucción jump.}
	\label{fig:DPmonocicloNoJump}
\end{figure}

\par Podemos notar en contraste con la figura \ref{fig:DPmonocicloOrig} que hay un multiplexor y un \emph{``shifter''} a izquierda de más. Siguiendo esta idea, pero un poco más complejo por ser multiciclo, podemos ver la diferencia entre la figura \ref{fig:DPpipelineOrig} y \ref{fig:DPpipelineJump}, donde se aplica este mismo concepto para la resolución de este punto.

\subsubsection{Modificación al set de instrucciones}
\par Para llevar a cabo este punto, primero que nada se agregó tanto el tipo de instrucción J, así como también la instrucción propiamente dicha al set de instrucciones \emph{default-no-jump.set}.
\begin{verbatim}
"types": {
    ...
    "J": [{"id": "op", "size": 6}, {"id": "target", "size": 26}]
},
"instructions": {
    ...
    "j": { "type": "J", "args": ["target"], "fields": {"op": 2,
           "target": "#1"}, "desc": "PC = target"
         },
    ...
}
\end{verbatim}
\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.37]{img/DPpipelineJump.pdf}
	\caption{Datapath pipeline con instrucción \emph{jump}.\protect\footnotemark}
	\label{fig:DPpipelineJump}
\end{figure}
\footnotetext{Se decidió no remarcar los componentes agregados ya que se perdía claridad de la conexión de los cables.}
\par Por otro lado, se agregó una salida de \emph{jump} en la unidad de Control, que indique si la instrucción es de jump:
\begin{verbatim}
"control": {
    ...
    "2": {"Jump": 1},
    ...
}
\end{verbatim}

\subsubsection{Modificación al datapath}
\par Por el lado del datapath propiamente dicho, tal como se puede ver en la figura \ref{fig:DPpipelineJump}, lo que se hizo fue agregar un multiplexor (Que está justo debajo del \emph{PC}) que decida entre \emph{PC+4/branch} y \emph{Jump}. Además, como ya se dijo, éste elige en base a la línea \emph{jump} de control que se agregó. Por otro lado, tal como se había mencionado anteriormente, se agregó el \emph{Shift Left 2}, que se encuentra arriba y a la izquierda del bloque \emph{Registers}.
\par En un principio se llevó a cabo que tanto el cable de \emph{target} (Que es el que sale del \emph{``shifter''} a izquierda agregado) como la línea de control del \emph{jump} siguieran guardándose en los registros intermedios del pipeline hasta luego del \emph{EX/MEM}, que es lo que se muestra en la resolución.
\par Luego se nos ocurrió una ``mejora'' que finalmente no prosperó: nos percatamos de que esto podía llegar a no ser así, ya que si al decodificarla ya se daba cuenta de que era un \emph{jump}, al ser el mismo completamente incondicional, se podía enviar directamente desde la etapa de \emph{IF/ID}, evitando así que se ejecuten 2 operaciones innecesarias luego del \emph{jump}. Esta ``mejora'' fue llevada a cabo, pero surgió un detalle: en una situación particular, que se ve plasmada en algunas de las pruebas realizadas (La 3 y la 6), donde el código contenía un \emph{jump} con una instrucción de por medio luego de un \emph{branch}, había problemas (Se ejecutaban instrucciones que no debían). Es por ello que se descartó esta ``mejora'', ya que no era del todo confiable, volviendo a la idea original de que estas líneas se lleven hasta la etapa de \emph{EX/MEM}.
\par Más allá de todo, aplicando la ``mejora'' o no, había algo que no estaba solucionado, lo cual representaba un \emph{\textbf{hazard}} de control: las 3 instrucciones siguientes al \emph{jump} se seguían ejecutando (Para disminuir esta cantidad a una instrucción es que se había planteado la ``mejora''). Para evitar dicho comportamiento, se hizo uso de la línea \emph{jump} de la unidad de Control para que con ella se haga un \emph{flush} del contenido de los registros del pipeline. Allí es donde se agregó la compuerta \emph{or} que se encuentra arriba a la derecha, donde al haber un \emph{jump} o un \emph{branch taken}, se hace un \emph{flush} de los registros del pipeline.

\subsubsection{Pruebas de jump}
\par Estas fueron las pruebas que se corrieron para verificar el correcto funcionamiento de la nueva instrucción:

\bigskip
\noindent \textbf{Prueba 1:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto2/prueba.asm}
\medskip
\textbf{Prueba 2:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto2/prueba2.asm}
\medskip
\textbf{Prueba 3:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto2/prueba3.asm}
\medskip
\textbf{Prueba 4:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto2/prueba4.asm}
\medskip
\textbf{Prueba 5:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto2/prueba5.asm}
\medskip
\textbf{Prueba 6:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto2/prueba6.asm}

\pagebreak

\subsection{Punto 3}
\par En este punto se implementó la instrucción \emph{jr} en el datapath monociclo; para ello, se modificó el datapath y el set de instrucciones:

\subsubsection{Modificación al set de instrucciones}
\par Se agregó un nuevo tipo de instrucción, \emph{JR}, con la siguiente configuración (Aunque se podría haber utilizado el tipo ``R'' para implementarla):
\begin{verbatim}
"types": {
    ...
    "JR": [ {"id": "op","size": 6},{"id": "rs","size": 5},
            {"id": "ceros", "size": 21} ]
}
\end{verbatim}
\par Los 6 bits más significativos corresponden al opcode, los siguientes 5 al registro que contiene la dirección a la cual se saltará y el resto, al no ser necesarios, son llenados con 0s.
\par Luego, se agrega la instrucción \emph{jr} en particular, siguiendo el formato previamente descripto. Se elige un opcode igual a 1 simplemente porque este numero no es utilizado en ninguna de las otras instrucciones, pero podría haberse elegido cualquier otro numero de 6 bits que no sea utilizado.
\begin{verbatim}
"instructions": {
    ...
    "jr": { "type": "JR","args": ["reg"] , 
            "fields": {"op": 1,"rs": "#1","ceros": 0 }
          }
},
\end{verbatim}
\par Finalmente se agrega una nueva salida a la unidad de control, \emph{JR} y se la configura para que al recibir un opcode igual a 1 esta salida sea activada y el resto permanezca sin activarse:
\begin{verbatim}
"control": {
    ...
    "1": { "JR":1 }
},
\end{verbatim}

\subsubsection{Modificación al datapath}

A continuación se presenta una imagen del datapath con los cambios realizados; los nuevos componentes agregados están resaltados con un círculo rojo:

\begin{figure}[H]
	\centering
	\includegraphics[width=1\columnwidth]{img/DPmonocicloJR-2.PNG}
	\caption{Datapath monociclo con la instrucción \emph{jr}}
\end{figure}

\par Como puede observarse, se agregó un \emph{fork} a la salida de los registros, el cual se dirige hacia una entrada de un nuevo multiplexor. La manera en la que esto funciona es la siguiente: 
\par Cuando la instrucción a ejecutarse es \emph{jr} ingresa un opcode igual a 1 a la unidad de control; esto setea todas las salidas a 0 menos la salida \emph{JR}, la cual es seteada en 1. Esta salida se dirige hacia el selector del nuevo multiplexor agregado. Si este bit es 1, entonces el multiplexor elige la entrada proveniente del registro y se lo pasa al \emph{PC} para que se salte a esa dirección. 
\par Si el bit selector es 0, como ocurre en el resto de las instrucciones, el datapath funciona normalmente, ya que el multiplexor utiliza la entrada que anteriormente tenía salida al \emph{PC}, por lo que no realiza ningún cambio.

\subsubsection{Pruebas de jr}
\par Estas fueron las pruebas que se corrieron para verificar el correcto funcionamiento de la nueva instrucción:

\bigskip
\noindent\textbf{Prueba 1:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto3/prueba.asm}
\medskip
\textbf{Prueba 2:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto3/prueba2.asm}
\pagebreak

\subsection{Punto 4}
\par En este punto se implementó la instrucción \emph{blt} (Branch if Less Than) en el datapath pipeline. En un comienzo se intentó resolverlo únicamente con pseudoinstrucciones, lo cual resultó insatisfactorio. Por ello, se buscó y se llegó a la conclusión que no bastaba sólo con eso, sino que además se tenía que implementar la instrucción de \emph{bne} (Branch if Not Equal).

\subsubsection{Modificación al set de instrucciones}
\par Para llevar a cabo este punto, como ya se dijo, se agregó la instrucción \emph{bne} y la pseudoinstrucción \emph{blt}.
\par Para el caso de \emph{bne} se tuvo que, además de agregar la instrucción, agregar una línea más de la unidad de control que indique si es un \emph{bne}. Al comienzo se intentó utilizando la de branch ya existente, pero nos resultó más fácil hacerlo habiendo 2 (Una para cada tipo de branch). Así, el archivo \emph{default\_no\_jump.set} sufrió las siguientes modificaciones:

\begin{verbatim}
"instructions": {
    ...
    "bne": { "type": "I", "args": ["reg", "reg", "offset"],
             "fields": {"op": 5, "rs": "#1", "rt": "#2", "imm": "#3"},
             "desc": "PC += ($t1 != $t2) ? (offset * 4 + 4) : 4"
           },
    ...
},
"pseudo": {
    ...
    "blt": { "args": ["reg", "reg", "offset"],
             "to": ["slt $1, #1, #2", "bne $1, $0, #3"],
             "desc": "PC += ($t1 < $t2) ? (offset * 4 + 4) : 4"
           },
    ...
},
"control": {
    ...
    "4": {"ALUOp": 1, "ALUSrc": 0, "BranchEQ": 1},
    "5": {"ALUOp": 1, "ALUSrc": 0, "BranchNE": 1},
    ...
}
\end{verbatim}

\subsubsection{Modificación al datapath}
\par La idea para este punto fue desarrollar más que nada la instrucción \emph{bne}, que luego utilizará la pseudoinstrucción \emph{blt}. Para ello, se hizo uso de las líneas \emph{BranchEQ} y \emph{BranchNE} de la unidad de control, junto con la salida \emph{zero} de la ALU. El concepto general recae en que se hará un branch si se cumplen algunas de estas 2 condiciones:
\begin{itemize}
	\item Es un \emph{bne} (que será indicado por la línea de control \emph{BranchNE}) y el resultado de restar los registros intervinientes no dio cero. Esto último indicaría que no son iguales, mediante la salida \emph{zero} con valor igual a \emph{0} de la ALU.
	\item Es un \emph{beq} (que será indicado por la línea de control \emph{BranchEQ}) y la salida \emph{zero} de la ALU tiene un valor 1 (Es decir, que se restaron los registros y el resultado dio cero, por lo que son iguales).
\end{itemize}
\par En cualquiera de los dos casos, el \emph{PC} no tomará el valor de la siguiente instrucción sino que se le asignará el valor del \emph{target}, además de hacer un \emph{flush} de los registros del pipeline.
\par Esto es lo que se quiere llevar a cabo con el circuito de 2 ANDs, 1 NOT y 1 OR que se encuentra arriba del \emph{Data Memory}, tal como se puede ver en la figura \ref{fig:DPpipelineBLT}.
\par En este punto, por ser sobre el datapath de pipeline, había que tener cuidado con los \emph{\textbf{hazards}}. Es por ello que se mantuvo la estructura de que la salida de la compuerta \emph{or} haga un \emph{flush} sobre los registros del pipeline al haber un \emph{branch taken}, tal como ya estaba hecho originalmente.
\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.37]{img/DPpipelineBLT.pdf}
	\caption{Datapath pipeline con instrucción \emph{bne} y pseudoinstrucción \emph{blt}.\protect\footnotemark}
	\label{fig:DPpipelineBLT}
\end{figure}
\footnotetext{Se decidió no remarcar los componentes agregados ya que se perdía claridad de la conexión de los cables.}

\subsubsection{Pruebas de blt}
\par Estas fueron las pruebas que se corrieron para verificar el correcto funcionamiento de las nuevas instrucciones:

\bigskip
\pagebreak
\noindent\textbf{Prueba 1:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto4/prueba.asm}
\medskip
\textbf{Prueba 2:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto4/prueba2.asm}
\medskip
\textbf{Prueba 3:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto4/prueba3.asm}
\medskip
\textbf{Prueba 4:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto4/prueba4.asm}
\medskip
\textbf{Prueba 5:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto4/prueba5.asm}
\medskip
\textbf{Prueba 6:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto4/prueba6.asm}
\medskip
\textbf{Prueba 7:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto4/prueba7.asm}
\medskip
\textbf{Prueba 8:}
\lstset{
	language=[mips]Assembler,
	tabsize=4,
	frame=single
}
\lstinputlisting{../punto4/prueba8.asm}

\pagebreak

\section{Conclusiones}

\par Realizar este trabajo práctico nos permitió interiorizarnos aún más con la arquitectura de CPU MIPS, más en particular con el datapath de la misma, y con el simulador DrMIPS. Nos sirvió para comprender como funciona el datapath monociclo y el pipeline, así como también para darnos cuenta que hay distintas formas de implementar una instrucción. 
\par En algunos casos es posible agregar instrucciones sin modificar el datapath, como en el caso de las instrucciones \emph{sll} y \emph{srl}, pero generalmente requiere el agregado de nuevos componentes, lo que implica más costos, un aumento en la complejidad del datapath y posiblemente una disminución en la velocidad de ejecución. Por lo cual, a la hora de elegir si agregar una nueva instrucción, deben considerarse estas desventajas.
\par Por último, pudimos observar que en determinados casos, como en el de \emph{blt}, no es posible agregar una nueva instrucción al datapath, sino que es necesario implementarla como una combinación de instrucciones ya existentes, o bien primero deben implementarse nuevas instrucciones (como el caso de \emph{bne}), para luego sí poder llevar a cabo la pseudoinstrucción \emph{blt}.

\section{Referencias}
\noindent[1] DrMIPS, \url{https://bitbucket.org/brunonova/drmips/wiki/Home}.\\ \relax
[2] DrMIPS, \url{https://https://github.com/brunonova/drmips}.\\ \relax

\newpage

\includepdf[pages={1-3}]{tp2-q2-2015.pdf}

\end{document}