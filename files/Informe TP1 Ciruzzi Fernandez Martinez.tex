\documentclass[a4paper,10pt]{article}

\usepackage{graphicx}
\usepackage[ansinew]{inputenc}
\usepackage[spanish]{babel}
\usepackage{listings} 
\usepackage{tabto}
\usepackage{float}
\usepackage[justification=centering]{caption}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{mips}
\usepackage[section]{placeins}
\usepackage{pdfpages}
\usepackage{enumitem}


\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\circ$}


\title{		\textbf{Trabajo práctico \#1: conjunto de instrucciones MIPS}}

\author{	Santiago Fernandez, \textit{Padrón Nro. 94.489}                     \\
            \texttt{ fernandezsantid@gmail.com }                                              \\[2.5ex]
            Pablo Rodrigo Ciruzzi, \textit{Padrón Nro. 95.748}                     \\
            \texttt{ p.ciruzzi@hotmail.com }                                              \\[2.5ex]
            Horacio Martinez, \textit{Padrón Nro. 94.926 }                     \\
            \texttt{ hmk142@hotmail.com }                                              \\[2.5ex]
            \normalsize{2do. Cuatrimestre de 2015}                                      \\
            \normalsize{66.20 Organización de Computadoras  $-$ Práctica Jueves}  \\
            \normalsize{Facultad de Ingeniería, Universidad de Buenos Aires}            \\
            \\
            \\
       }
\date{ 24 de Septiembre, 2015}

\begin{document}

\maketitle
\thispagestyle{empty}   % quita el número en la primer página


\begin{abstract}
Este trabajo práctico trata de una versión en lenguaje C, de un programa que computa autómatas celulares para reglas y estados iniciales arbitrarios. Además, se hizo un version en Assembly de una función para familiarizarse con el conjunto de instrucciones MIPS32 y el concepto de ABI.
\end{abstract}
\pagebreak 

\tableofcontents
\pagebreak

\section{Introducción}
Un autómata celular es un modelo matemático para un sistema dinámico que evoluciona en pasos discretos; en este trabajo desarrollamos el autómata no trivial más simple que consiste en una retícula unidimensional de células que sólo pueden tener dos estados (0 o 1), con un vecindario constituido, para cada célula, de ella misma y de las dos células adyacentes ($2^{3}=8$ configuraciones posibles).
\par Existen $2^{8}=256$ modos de definir cuál ha de ser el estado de una célula en la generación siguiente para cada una de estas configuraciones. Estos modos se codifican según un número (llamado de regla) propuesto por Stephen Wolfram.
\par Dado un número de regla y un estado inicial de N celdas, este programa se encarga de calcular los siguientes N estados para dicha configuración y escribirlos en una imagen de formato pbm.
\section{Desarrollo}

\subsection{Recursos y Portabilidad}

Uno de los objetivos del trabajo práctico es poder probar la portabilidad del
programa en diferentes entornos. En el enunciado se pedía que el programa se pudiera ejecutar en NetBSD[1] (usando el simulador GXemul[2]) y en la versión de Linux (Knoppix, RedHat, Debian, Ubuntu) usada para correr el simulador. En particular, se lo probó en Ubuntu 14.04. En GXemul se corrió una máquina de arquitectura MIPS cuyo sistema operativo era una versión reciente de NetBSD. La transferencia de archivos entre la máquina host y la guest se hizo mediante \textit{SSH}. Se procedió de la siguiente manera:

Para trabajar con el GXemul se procedió primero creando una nueva interfaz de red (debe crearse cada vez que se inicia el \textit{host} y con permisos de administrador):
\\

\emph{hostOS\$ sudo ifconfig lo:0 172.20.0.1}
\\

Luego se ejecutó el GXemul en modo X:
\\

\emph{hostOS\$ ./xgxemul -e 3max -d netbsd-pmax.img -x}
\\

Una vez ya ingresado con el usuario y la contraseña en la máquina simulada,
se creó un túnel reverso para saltear las limitaciones propias del GXemul:
\\

\emph{guestOS\$ ssh -R 2222:127.0.0.1:22 usuario@172.20.0.1}
\\

A partir de ese momento y dejando lo anterior en segundo plano, ya se puedo
trabajar mediante SSH de manera más cómoda:
\\

\emph{hostOS\$ ssh -p 2222 root@127.0.0.1}
\\

\subsection{Implementación}
La implementación del autómata celular unidimensional[3], tal como se lo explicó en la sección \textit{Introducción}, se hizo íntegramente en el lenguaje de programación C. Luego, también se desarrolló una de las funciones que ya se había implementado en C, en Assembler de una máquina de arquitectura MIPS32. La función a desarrollar en ambos lenguajes fue la función \textit{proximo} la cual, dadas la matriz y la celda que se quiere saber su próximo estado, devuelve este último. Para el pasaje entre C y Assembler se hizo uso de la ABI [4] explicada en la materia.
\par El resultado de la ejecución del programa es guardado en un archivo PBM[5] el cual muestra el avance del autómata a través de los pasos discretos.

\subsection{Compilación}

Para compilar el trabajo práctico, realizamos un Makefile para hacer mas sencilla esta tarea.\\

\par Para compilar para C:
\emph{make c}\\

Para compilar para MIPS:
\emph{make mips}\\

Finalmente para limpiar los archivos:
\emph{make clean}

\subsection{Corrida de Pruebas}
Teniendo en cuenta un archivo inicial de 80 caracteres de que tiene el siguiente formato: \\
\emph{\textbf{\$ cat inicial \\}
00000000000000000000000000000000000000010000000000000000000000000000000000000000 \\}
Y no habiendo ningun otro archivo en la carpeta raiz del proyecto, se hicieron las siguientes pruebas:
\begin{itemize}
	\NumTabs{4}
	\item Como primer medida ejecutamos el comando -h para ver la ayuda: 
		\emph{
			\begin{itemize}[noitemsep,nolistsep]
				\item \textbf{\$ autcel -h \\}
					Uso: \\
					autcel -h \\
					autcel -V \\
					autcel R N inputfile [-o outputprefix] \\
					 \\
					Opciones: \\
					\tab{-h, --help}
					\tab{Imprime este mensaje.} \\
					\tab{-V, --version}
					\tab{Da la version del programa.} \\
					\tab{-o}
					\tab{Prefijo de los archivos de salida.} \\
					 \\
					Ejemplo: \\
					autcel 30 80 inicial -o evolucion \\
					Calcula la evolucion del automata ``Regla 30'', en un mundo unidimensional de 80 celdas, por 80 iteraciones. \\
					El archivo de salida se llamara evolucion.pbm. \\
					Si no se da un prefijo para los archivos de salida, el prefijo sera el nombre del archivo de entrada.
			\end{itemize}
		}
	\item Y luego el comando -V para ver la version: 
		\emph{
			\begin{itemize}[noitemsep,nolistsep]
				\item \textbf{\$ autcel -V \\}
					autcel: version 1.0
			\end{itemize}
		}
	\item Primero probamos los ``casos felices'': 
		\emph{
  			\begin{itemize}[noitemsep,nolistsep]
    				\item \textbf{\$ ./autcel 30 80 inicial \\}
					Leyendo estado inicial... \\
					Calculando los 79 estados siguientes... \\
					Grabando inicial.pbm \\
					Listo. \\
				\item \textbf{\$ ./autcel 30 80 inicial -o final \\}
					Leyendo estado inicial... \\
					Calculando los 79 estados siguientes... \\
					Grabando final.pbm \\
					Listo.
			\end{itemize}
		}
	\item Luego probamos sin enviar ningun tipo de parametro: 
		\emph{
			\begin{itemize}[noitemsep,nolistsep]
				\item \textbf{\$ autcel \\}
					El comando ejecutado no respeta la sintaxis. Para mas ayuda ejecutar el programa con -h o --help.
			\end{itemize}
		}
	\item Y también cualquier otra idea que se nos ocurrió: 
		\emph{		
			\begin{itemize}[noitemsep,nolistsep]
				\item \textbf{\$ ./autcel -p \\}
					El comando ejecutado no respeta la sintaxis. Para mas ayuda ejecutar el programa con -h o --help. \\
				\item \textbf{\$ ./autcel 30 80 \\}
					El comando ejecutado no respeta la sintaxis. Para mas ayuda ejecutar el programa con -h o --help. \\
				\item \textbf{\$ ./autcel 30 80 primero \\}
					El archivo de entrada especificado no se ha podido abrir o no existe. \\
				\item \textbf{\$ ./autcel -1 80 inicial \\}
					El numero de regla no es valido. Debe ser un valor numerico entre 0 y 255. \\
				\item \textbf{\$ ./autcel 256 80 inicial \\}
					El numero de regla no es valido. Debe ser un valor numerico entre 0 y 255. \\
				\item \textbf{\$ ./autcel hola 80 inicial \\}
					El numero de regla no es valido. El mismo no contiene un valor numerico o se ha producido un overflow. \\
				\item \textbf{\$ ./autcel 30 -8 inicial \\}
					El numero de celdas e iteraciones (``N'') no es valido. Debe ser un valor numerico entre 1 y 10000. \\
				\item \textbf{\$ ./autcel 30 hola inicial \\}
					El numero de celdas e iteraciones (``N'') no es valido. El mismo no contiene un valor numerico o se ha producido un overflow. \\
				\item \textbf{\$ ./autcel 30 11111 inicial \\}
					El numero de celdas e iteraciones (``N'') no es valido. Debe ser un valor numerico entre 1 y 10000. \\
				\item \textbf{\$ ./autcel 30 80 inicial final \\}
					El comando ejecutado no respeta la sintaxis. Para mas ayuda ejecutar el programa con -h o --help. \\
				\item \textbf{\$ ./autcel 30 80 inicial -p final \\}
					El comando ejecutado no respeta la sintaxis. Para mas ayuda ejecutar el programa con -h o --help.
			\end{itemize}
		}
	\item Las próximas pruebas se refieren a errores en el archivo de entrada (Recordar que es un archivo de 80 caracteres, con todos 0 salvo el caracter central que es un 1): 
		\emph{
			\begin{itemize}[noitemsep,nolistsep]
				\item \textbf{\$ ./autcel 30 15 inicial \\}
					Leyendo estado inicial... \\
					La cantidad de columnas en el archivo de entrada es mayor a la longitud indicada por ``N''. \\
				\item \textbf{\$ ./autcel 30 90 inicial \\}
					Leyendo estado inicial... \\
					La cantidad de columnas en el archivo de entrada es menor a la longitud indicada por ``N''.
			\end{itemize}
		}
	\item Cambiando el archivo inicial de las maneras que muestra el comando \textit{cat}: 
		\emph{
			\begin{itemize}[noitemsep,nolistsep]
				\item \textbf{\$ cat inicial \\}
					hola \\
					\textbf{\$ ./autcel 30 80 inicial \\}
					Leyendo estado inicial... \\
					El formato del archivo de entrada no es correcto. \\
				\item \textbf{\$ cat inicial \\}
	0000000000000000000000000000000000000001000000000000000000000000000000000000000\underline{h}\\
					\textbf{\$ ./autcel 30 80 inicial \\}
					Leyendo estado inicial... \\
					El formato del archivo de entrada no es correcto.
			\end{itemize}
		}
\end{itemize}

\newpage
\subsection{Código}
\subsubsection{Código en C}
\lstset{
	language=C, columns=flexible, breaklines=true, frame=single, title=proximo.h
}
\lstinputlisting{../src/proximo.h}
\lstset{
	title=proximo.c
}
\lstinputlisting{../src/proximo.c}
\lstset{
	title=main.c
}
\lstinputlisting{../src/main.c}

\subsubsection{Código función proximo en Assembler}
\lstset{
	language=[mips]Assembler,
	title=proximo.S,
	tabsize=4
}
\lstinputlisting{../src/proximo.S}

\newpage
\subsubsection{Código del Makefile}
\lstset{
	language=[gnu] make,
	title=Makefile
}
\lstinputlisting{../Makefile}
\pagebreak

\subsection{Diagrama de Stack}
\subsubsection{Función proximo}
Aquí presentamos un diagrama del Stack de la función \textit{proximo}. Vale aclarar que en el mismo, se incluye el ABA (Argument Building Area) de la función que la llama (En este caso la función \textit{calcularFilas}). Como la cantidad de argumentos que recibe \textit{proximo} es mayor que 4, necesitamos agregarlos a ``mano'' y, para que quede múltiplo de 8 bytes, agregamos un padding. A su vez, al ser \textit{proximo} una función ``hoja'', su stack no posee ABA.
\par Por otra parte también consideramos importante mencionar que tanto el SRA (Saved Register Area, que incluye al GP y FP) como LTA (Local Temporary Area, que incluye a las varibles utilizadas en la función) son múltiplo de 8 bytes, por lo que no requieren del agregado de un padding. \\
\\
Stack Size función \textit{proximo}:  24
\begin{table}[h]
\centering
\begin{tabular}{|l|l|} \hline
 PADDING& 44 \\ \hline %Hay que ponerlo no??
 A4&  40  \\ \hline
 A3&  36  \\ \hline
 A2&  32  \\ \hline
 A1&  28  \\ \hline
 A0&  24  \\ \hline
 FP&  20  \\ \hline
 GP&  16  \\ \hline
 POS&  12  \\ \hline
 ACTUAL&  8  \\ \hline
 DER&  4  \\	\hline
 IZQ&  0  \\ \hline
\end{tabular}
\caption {Stack de la función proximo}
\end{table} \\

\newpage

\section{Resultados}
En las figuras \ref{fig:regla30}, \ref{fig:regla110} y \ref{fig:regla126} podemos observar los resultados de las corridas pedidas por los docentes de la materia. Todas ellas parten de un archivo inicial de 80 caracteres con una celda ocupada en el centro: \\
\emph{\textbf{\$ cat inicial \\}
00000000000000000000000000000000000000010000000000000000000000000000000000000000 \\}

\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.65]{../salida3080Mips.pdf}
	\caption{Regla 30}
	\label{fig:regla30}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.65]{../salida11080Mips.pdf}
	\caption{Regla 110}
	\label{fig:regla110}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.65]{../salida12680Mips.pdf}
	\caption{Regla 126}
	\label{fig:regla126}
\end{figure}

\section{Conclusiones}

\par De este trabajo practico se pudo aprender como programar con el conjunto de instrucciones Assembly de MIPS32, asi como tambien la utilizacion correcta de la ABI de la catedra, entendiendo de esta manera como funciona una computadora a bajo nivel.
\par Mencionar el hecho de que en NetBSD corre más lento!

\newpage

\section{Referencias}
\noindent[1] The NetBSD project, \url{http://www.netbsd.org/}.\\ \relax
[2] GXemul, \url{http://gavare.se/gxemul/}.\\ \relax
[3] Autómatas celulares elementales: \url{http://mathworld.wolfram.com/ElementaryCellularAutomaton.html}.\\ \relax
[4] func\_call\_conv.pdf, en el area de Material de los archivos del grupo de Yahoo.\\ \relax
[5] Formato PBM: \url{http://netpbm.sourceforge.net/doc/pbm.html}.\\ \relax

\newpage

\includepdf[pages={1-8}]{tp1-c2-2015.pdf}

\end{document}